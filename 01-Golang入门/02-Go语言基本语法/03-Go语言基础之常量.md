# 常量

相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 



## 常量声明

常量的声明和变量声明非常类似，只是把`var`换成了`const`。常量在声明了之后，在整个程序运行期间它们的值都不能再发生变化了。



### 标准声明

基本语法如下：

```go
const 常量名 [常量类型] = 表达式
```

常量在定义的时候必须赋值：

```go
const pi float32 = 3.1415
const e int32 = 2
```



### 常量推导

一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。基本语法如下：

```go
const 常量名 = 表达式
```

举例：

```go
const noDelay time.Duration = 0
const timeout = 5 * time.Minute
```



### 批量声明

多个常量也可以一起声明：

```go
const (
  pi = 3.1415
  e = 2.7182
)
```

const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：

```go
const (
  n1 = 100
  n2
  n3
)
```

上面示例中，常量`n1`、`n2`、`n3`的值都是100。



## iota

`iota`是 Go 语言的常量计数器，**只能**在常量的表达式中使用。

`iota`在 const 关键字出现时将被重置为`0`。const 中每新增一行常量声明将使`iota`计数一次（iota 可理解为 const语句块中的行索引）。 使用 iota 能简化定义，在定义枚举时很有用。

举个例子：

```go
const (
  n1 = iota //0
  n2 = iota //1
  n3 = iota //2
  n4 = iota //3
)

# 在一个 const 段中，iota 可以省略
const (
  n1 = iota //0
  n2        //1
  n3        //2
  n4        //3
)
```



### 常见的`iota`示例

使用`_`跳过某些值：

```go
const (
	n1 = iota //0
	n2        //1
	_
	n4        //3
)
```

`iota`声明中间插队：

```go
const (
	n1 = iota //0
	n2 = 100  //100
	n3 = iota //2
	n4        //3
)
const n5 = iota //0
```

定义数量级：

```go
const (
	_  = iota // 0
  KB = 1 << (10 * iota)  	// 2^(10*1); iota=1
  MB = 1 << (10 * iota) 	// 2^(10*2); iota=2
	GB = 1 << (10 * iota) 	// 2^(10*3); iota=3
	TB = 1 << (10 * iota) 	// 2^(10*4); iota=4
	PB = 1 << (10 * iota) 	// 2^(10*5); iota=5
)
```

这里的`<<`表示左移操作，`1<<10`表示将1的二进制表示向左移10位，也就是由`1`变成了`10000000000`，也就是十进制的1024。同理`2<<2`表示将2的二进制表示向左移2位，也就是由`10`变成了`1000`，也就是十进制的8。



多个`iota`定义在一行：

```go
const (
  a, b = iota + 1, iota + 2 //1,2；iota=0
  c, d                      //2,3；iota=1
  e, f                      //3,4；iota=2
)
```



## 无类型常量

Go 语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如 int 或 float64，或者是类似 time.Duration 这样的基础类型，但是许多常量并没有一个明确的基础类型。

编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有 256bit 的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。

通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。

【示例 2】math.Pi 无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：

```
纯文本复制
var x float32 = math.Pivar y float64 = math.Pivar z complex128 = math.Pi
```

如果 math.Pi 被确定为特定类型，比如 float64，那么结果精度可能会不一样，同时对于需要 float32 或 complex128 类型值的地方则需要一个明确的强制类型转换：

```
纯文本复制
const Pi64 float64 = math.Pivar x float32 = float32(Pi64)var y float64 = Pi64var z complex128 = complex128(Pi64)
```

对于常量面值，不同的写法可能会对应不同的类型。例如 0、0.0、0i 和 \u0000 虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true 和 false 也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。




----

本文原始来源 [Endial Fang](https://github.com/endial) @ [Github.com](https://github.com) ([项目地址](https://github.com/endial/study-golang.git))
